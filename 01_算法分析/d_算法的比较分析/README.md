## 算法如何比较
在实际开发中，通常会有多个算法可以解决一个问题，那么我们就要择优而取。如何取最优算法呢？  

假设有两个算法能解决同一个问题，算法A的复杂度为O(n)，算法B的时间复杂度为O(n^2)。从下面的表格中，我们可以看到，`n^2`的增长率
是高于 `n`的，可自行画到坐标系中，更直观一点。也就是说g(n) = n比g(n) = n^2更具有渐进性，所以我们会选择算法A（O(n)）

|  n  | log(n) |  n  | n*log(n) | n^2 | n^3 | 2^n |
| --- |  ----  | --- |   ----   | --- | --- | --- |
|  8  |  3  | 8 |   24   | 64 | 512 | 256 |
|  16 |  4  | 16 |   64   | 256 | 4 096 | 65 536 |
|  32 |  5  | 32 |   160   | 1 024 | 32 768 | 4 294 967 296 |
|  64 |  6  | 64 |   384   | 4 096 | 262 144 | 1.84 * 10^19 |
| 128 |  7  | 128 |   896   | 16 384 | 2 097 152 | 3.40 * 10^38 |
| 256 |  8  | 256 |   2 048   | 65 536 | 16 777 216 | 1.15 * 10^77 |
| 512 |  9  | 512 |   4 608   | 262 144 | 134 217 728 | 4.34 * 10^152 |

## 哪些算法是高效的，可以被接受的呢？
在实际工作中，我们一般选择O(n)、O(log(n))、O(n)、O(n*log(n)) 这四种复杂度的算法，在n取值范围较小的情况下O(n^2)复杂度的算法也是
可以接受的，而对于O(n^3)或者O(2^n)复杂度的算法，一般情况下就将放弃并开发其他更优的算法。

## 算法复杂度的陷阱
算法的选择优先级一定是 O(n) > O(log(n)) > O(n) > O(n*log(n)) > O(n^2) 吗？  
答案是否定的！  
在描述算法复杂度的时候，我们会忽略低阶项和常量因子，但是这有一个前提：常量因子不能太大。  
比如：  
算法A的函数为(10^100)*log(n)，那么复杂度为O(log(n))  
算法B的函数为10n，那么复杂度为O(n)  
在这种情况下，我们更倾向于选择算法B。在实际工作中，要注意这种常量因子特别大的情况，做出正确的选择。

# NEXT
[算法分析示例](../e_算法分析示例)