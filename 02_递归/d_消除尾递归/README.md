## 消除尾递归
递归算法能够使我们简单的利用重复结构呈现诸多问题，可以避开复杂的嵌套循环与分析，使代码的可读性更强。然而，任何项目的开发都要基于成本，
既然go语言不支持尾递归优化，递归调用所带来的性能损失也无法接受，那么从尾递归得到非递归算法就非常有用了。

## 手动压栈消除尾递归
手动创建一个栈结构，模拟运行时函数调用的入栈出栈场景，在栈中我们可以存储尽可能少的数据达到我们循环处理的目的。
这种方式仅仅是从运行时的栈操作变为手动模拟，更理想的情况是，我们不需要借助任何辅助存储空间将尾递归消除，
也就是我们最常用的循环。
[手动压栈实现阶乘](../../code/02/factorial.go)

## 利用循环逻辑消除尾递归
任何一个尾递归都可以被非递归的实现。

对于尾递归来说，递归调用的层数，就是循环体的执行次数，函数中的逻辑语句可以作为循环体，我们可以很轻松的将尾递归用循环实现。

[循环实现阶乘](../../code/02/factorial.go)