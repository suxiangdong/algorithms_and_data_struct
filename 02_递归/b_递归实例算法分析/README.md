## 阶乘
阶乘的定义为：  
n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1 其中n ≥ 1，  当n = 0时，n! = 1

针对阶乘的定义，我们可以分析得到:  
n! = n * (n - 1)! 其中 n ≥ 1，当n = 0时，n! = 1  
这是一个典型的递归定义，基本情况是n=0时，n!=1；递归情况是n≥1时，n! = n * (n-1)!。

[阶乘函数递归实现](../../code/02/factorial.go)  

#### 阶乘递归算法分析（函数Factorial1）
在最开始我们已经知道，函数返回和乘法是一个原子操作，那么n=0的时候操作数为1，递归调用部分操作数取决于n值，即n次，
那么这个算法函数的原子操作执行次数为 n + 1，所以时间复杂度为O(n)

## 斐波那契数列
定义：  
f(0) = 0  
f(1) = 1  
f(n) = f(n-1) + f(n-2) 其中n ≥ 2

[斐波那契函数递归实现](../../code/02/fib.go)

#### 斐波那契递归算法分析 (函数Fib1)
第一个函数是最贴合题意思路的解法，同时这也是效率最低的解法。可以想象为一个二叉树，当n大于等于3时，
每次调用会分解为另外两个函数调用，当n很大时，调用次数的量级为2^n，所以时间复杂度为O(2^n)，是一个很糟糕的算法，
后面的章节，我们会对这种递归算法进行优化。

## 二分查找
定义：二分查找的一个必要条件是待查找的序列是有序的，这样可以取序列的中位索引，将中位值与目标值比较，相等直接返回，否则，
可以直接确定目标值的所在区间，重复这个过程，直到找到目标值或者区间缩小为0为止。  

[二分查找函数递归实现](../../code/02/binary_search.go)  

#### 二分查找递归算法分析（函数BinarySearch1）
我们可以看到在函数中，输入大小为序列的长度n，每调用一次函数，n的大小（确定的序列区间大小）变为n/2，假设最坏情况下，
需要执行i次，使区间变为1，那么就可以得到公式 n/(2^i) = 1，i = log(n)，所以时间复杂度为O(log(n))

## 时间复杂度对比
阶乘递归函数实现的时间复杂度为O(n)  
斐波那契递归函数实现的时间复杂度为O(2^n)  
二分查找递归函数实现的时间复杂度为O(log(n))  

可以看到，递归算法的时间复杂度大不一样，O(n)的阶乘递归算法还需要优化吗？O(2^n)的斐波那契递归算法怎么优化呢？二分查找还能优化吗？
下一节将会分析一下递归的优化原理。

# NEXT
[尾递归](../c_尾递归)