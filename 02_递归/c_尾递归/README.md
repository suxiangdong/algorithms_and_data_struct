## 递归算法的不足
递归是一种很很强大的工具，但是十分容易误用。

在上一节中斐波那契数列的递归函数，就是一种极其糟糕的实现，不仅仅时间复杂度高达O(2^n)，
而且每一次递归调用都需要保存上下文环境，将返回的结果再次进行计算，这也会严重影响代码执行的效率。

## 尾递归
定义：如果每次递归调用的返回值可以立即返回，不需要额外的计算，那么这个递归就是一个尾递归。  

[阶乘递归实现](../../code/02/factorial.go)  
[单元测试&基准测试](../../code/02/factorial_test.go)

对比尾递归与普通递归的基准测试结果可以发现，在相同输入的情况下，尾递归算法的效率是优于普通递归的，可以说尾递归的效率是完全碾压普通递归函数的。

在普通递归函数中，每次进行函数调用时都需要保存当前函数的上下文环境，当栈的上层函数调用时，都需要恢复当前函数的上下文环境后，再次进行计算；
尾递归函数仅仅需要将结果返回，省去了当前环境中变量的存储与恢复，效率得以提升。

## 尾递归优化
尾递归已经优于普通递归了，那如何进行优化呢？

阶乘普通递归函数展开后：  
factorial(5)  
5 * factorial(4)  
5 * (4 * (factorial(3)))  
......  
5 * (4 * (3 * (2 * (1 * factorial(0)))))  
5 * (4 * (3 * (2 * (1 * 1))))  
5 * (4 * (3 * (2 * 1)))  
......  
5 * 24  
120

阶乘尾递归函数展开后：  
factorial(5, 1)  
factorial(4, 5)  
factorial(3, 20)  
factorial(2, 60)  
factorial(1, 120)  
factorial(0, 120)  
120

通过观察我们可以发现，尾递归函数最后的结果仅仅与最后一次执行结果有关，中间过程的函数调用都是可以省略的。
如果在编译阶段，将尾递归函数调用优化为展开结果中最后一个函数调用，那么函数调用栈所占用的空间就是一个常量，不会有栈溢出的风险，效率会急剧提升。

如果语言不支持为递归优化，尾递归调用一样是需要多次进行函数栈的压如，有栈溢出风险的。不巧的是，go语言并不支持尾递归优化，
具体为什么就不清楚了，可能是不需要吧。我所知道的只有erlang是支持尾递归优化的。

函数调用的入栈和出栈所带来的性能损失是我们不能接受的，既然go语言不支持尾递归优化，那么我们就可以尝试手动优化，消除尾递归！

# NEXT
[消除尾递归](../d_消除尾递归)