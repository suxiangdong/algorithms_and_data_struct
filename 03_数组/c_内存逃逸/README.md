## 内存逃逸 vs 内存溢出
大家肯定对内存溢出耳熟能详，而内存逃逸与内存溢出是完全不同的两个概念：
1. 内存溢出是当越来越多的内存无法被回收或者申请的内存过大，导致系统无法提供程序运行所需的内存，使程序无法正常运行。
2. 内存逃逸是在编译期间确定的变量不能在栈中分配内存，必须到堆中去分配内存的情况。在go语言中可以通过`go build -gcflags='-m'`
来进行逃逸分析，一般表现为 `x escape to heap`

## 为什么内存逃逸会导致运行效率下降
普通情况下，局部变量会在当前函数栈中申请内存进行初始化，并随着函数执行结束而释放。堆适合不可预知大小的内存分配，代价就是
分配速度较慢，且会形成内存碎片。同时，在堆上分配的内存需要通过垃圾回收才能释放，会频繁引起gc，而gc的开销是很大的。

## 引起内存逃逸的情况
1. 指针逃逸：函数返回引用，更贴切的说应该是函数中的局部变量，在函数外仍然被引用。比如返回一个引用变量，但是函数外没有使用，在经过
编译器的逃逸分析之后，最后还是会分配到栈上。  
示例详解：[pointerEscape](../../code/03/escape/pointer/main.go)
2. interface{}逃逸：空接口可以表示任意类型，在编译期间无法确定变量的具体类型，会发生逃逸。  
示例详解：[interfaceEscape](../../code/03/escape/interface/main.go)
3. 变量占用内存过大，栈内存不足。  
示例详解：[stackEscape](../../code/03/escape/stack/main.go)
4. 闭包逃逸，与指针逃逸类似，局部变量在闭包函数引用，并不能随着函数执行结束而释放。  
示例详解：[closureEscape](../../code/03/escape/closure/main.go)

## 逃逸分析
通常我们不需要关心内存到底是分配在栈上还是堆上，编译器在编译阶段会进行逃逸分析，确定内存的分配方式。
了解逃逸分析规则，可以避免盲目的使用指针作为参数传递。虽然使用指针可以减少复制操作，但是分配到堆上的内存引起的gc压力
很可能会大于复制操作（复制是在栈上完成的操作）。